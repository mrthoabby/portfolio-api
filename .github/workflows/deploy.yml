name: Build and Deploy

on:
  push:
    tags:
      - 'v*'

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    concurrency:
      group: deploy-portfolio-api
      cancel-in-progress: true
    permissions:
      contents: read
      packages: write
      id-token: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository_owner }}/portfolio-api
          tags: |
            type=ref,event=tag
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Set build date
        id: build_date
        run: |
          BUILD_DATE=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          echo "build_date=${BUILD_DATE}" >> $GITHUB_OUTPUT

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILD_DATE=${{ steps.build_date.outputs.build_date }}
            VERSION=${{ github.ref_name }}

      - name: Deploy to server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: ${{ secrets.DEPLOY_PORT || 22 }}
          timeout: 300s
          command_timeout: 600s
          script: |
            set -e
            
            echo "=========================================="
            echo "  Portfolio API - Deploy"
            echo "=========================================="
            echo ""
            
            # Variables
            IMAGE_NAME="ghcr.io/${{ github.repository_owner }}/portfolio-api"
            TAG="${{ github.ref_name }}"
            CONTAINER_NAME="portfolio-api"
            APP_DIR="/opt/portfolio-api"
            HEALTH_CHECK_URL="http://localhost:1000/health"
            MAX_RETRIES=10
            RETRY_DELAY=3
            
            # Colores para output
            GREEN='\033[0;32m'
            YELLOW='\033[1;33m'
            RED='\033[0;31m'
            NC='\033[0m' # No Color
            
            # Verificar conectividad básica
            echo -e "${YELLOW}Verifying server connectivity...${NC}"
            if ! ping -c 2 localhost > /dev/null 2>&1; then
              echo -e "${RED}✗ Server connectivity check failed${NC}"
              exit 1
            fi
            echo -e "${GREEN}✓ Server is reachable${NC}"
            echo ""
            
            # Paso 1: Detener y eliminar el contenedor existente
            echo -e "${YELLOW}Stopping and removing existing container...${NC}"
            if docker ps -a --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
              docker stop ${CONTAINER_NAME} 2>/dev/null || true
              docker rm ${CONTAINER_NAME} 2>/dev/null || true
              echo -e "${GREEN}✓ Container stopped and removed${NC}"
            else
              echo -e "${GREEN}✓ No existing container found${NC}"
            fi
            
            # Paso 2: Limpiar TODAS las imágenes anteriores de portfolio-api
            echo -e "${YELLOW}Cleaning up all previous images...${NC}"
            OLD_IMAGES=$(docker images ${IMAGE_NAME} --format "{{.ID}}" 2>/dev/null || echo "")
            if [ -n "${OLD_IMAGES}" ]; then
              echo "${OLD_IMAGES}" | xargs -r docker rmi -f 2>/dev/null || true
              echo -e "${GREEN}✓ All previous images removed${NC}"
            else
              echo -e "${GREEN}✓ No previous images found${NC}"
            fi
            
            # Limpiar imágenes huérfanas (dangling images)
            docker image prune -f 2>/dev/null || true
            
            # Paso 3: Login a GitHub Container Registry
            echo -e "${YELLOW}Logging in to GitHub Container Registry...${NC}"
            # Login usando PAT si está disponible (necesario para repositorios privados)
            if [ -n "${{ secrets.GHCR_PAT }}" ]; then
              echo "${{ secrets.GHCR_PAT }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin || {
                echo -e "${RED}✗ Error: Could not login to GHCR${NC}"
                exit 1
              }
              echo -e "${GREEN}✓ Logged in to GHCR${NC}"
            else
              echo -e "${YELLOW}⚠ No GHCR_PAT secret found, assuming public repository${NC}"
            fi
            
            # Paso 4: Pull de la nueva imagen
            echo -e "${YELLOW}Pulling new image with tag: ${TAG}...${NC}"
            if docker pull ${IMAGE_NAME}:${TAG}; then
              echo -e "${GREEN}✓ Image pulled with tag ${TAG}${NC}"
              docker tag ${IMAGE_NAME}:${TAG} ${IMAGE_NAME}:latest
            else
              echo -e "${RED}✗ Error: Could not pull image with tag ${TAG}${NC}"
              exit 1
            fi
            
            # Verificar que existe el archivo .env
            if [ ! -f "${APP_DIR}/.env" ]; then
              echo -e "${RED}✗ Error: .env file not found at ${APP_DIR}/.env${NC}"
              echo -e "${YELLOW}Please create the .env file with required environment variables${NC}"
              exit 1
            fi
            
            # Paso 5: Iniciar el nuevo contenedor con puerto público (interno y externo)
            echo -e "${YELLOW}Starting new container...${NC}"
            if ! docker run -d \
              --name ${CONTAINER_NAME} \
              --restart unless-stopped \
              --env-file ${APP_DIR}/.env \
              -p 1000:8080 \
              ${IMAGE_NAME}:latest; then
              echo -e "${RED}✗ Error starting container${NC}"
              exit 1
            fi
            
            echo -e "${GREEN}✓ Container started successfully${NC}"
            
            echo ""
            echo -e "${YELLOW}Waiting for container to be ready...${NC}"
            sleep 5
            
            # Health check con retries
            HEALTH_CHECK_PASSED=false
            for i in $(seq 1 ${MAX_RETRIES}); do
              if curl -f ${HEALTH_CHECK_URL} > /dev/null 2>&1; then
                HEALTH_CHECK_PASSED=true
                echo -e "${GREEN}✓ Health check passed (attempt ${i}/${MAX_RETRIES})${NC}"
                break
              else
                echo -e "${YELLOW}⚠ Health check failed (attempt ${i}/${MAX_RETRIES}), retrying in ${RETRY_DELAY}s...${NC}"
                sleep ${RETRY_DELAY}
              fi
            done
            
            if [ "${HEALTH_CHECK_PASSED}" = "false" ]; then
              echo -e "${RED}✗ Health check failed after ${MAX_RETRIES} attempts${NC}"
              echo -e "${YELLOW}Container logs:${NC}"
              docker logs --tail 50 ${CONTAINER_NAME}
              
              # Rollback no disponible ya que limpiamos todas las imágenes anteriores
              echo -e "${YELLOW}⚠ Rollback not available - all previous images were cleaned${NC}"
              echo -e "${YELLOW}Please check the container logs above and fix the issue${NC}"
              
              exit 1
            fi
            
            echo ""
            echo -e "${YELLOW}Container status:${NC}"
            docker ps --filter "name=${CONTAINER_NAME}" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            
            echo ""
            echo -e "${YELLOW}Container logs (last 20 lines):${NC}"
            docker logs --tail 20 ${CONTAINER_NAME}
            
            # Paso 6: Limpiar imágenes huérfanas y sin usar después del deploy
            echo ""
            echo -e "${YELLOW}Final cleanup of unused images...${NC}"
            docker image prune -f 2>/dev/null || true
            
            # Eliminar todas las imágenes de portfolio-api excepto la que está corriendo
            CURRENT_IMAGE=$(docker inspect ${CONTAINER_NAME} --format='{{.Image}}' 2>/dev/null || echo "")
            ALL_IMAGES=$(docker images ${IMAGE_NAME} --format "{{.ID}}" 2>/dev/null || echo "")
            if [ -n "${ALL_IMAGES}" ] && [ -n "${CURRENT_IMAGE}" ]; then
              for img_id in ${ALL_IMAGES}; do
                if [ "${img_id}" != "${CURRENT_IMAGE}" ]; then
                  docker rmi -f ${img_id} 2>/dev/null || true
                fi
              done
              echo -e "${GREEN}✓ Unused images cleaned${NC}"
            else
              echo -e "${GREEN}✓ No unused images to clean${NC}"
            fi
            
            echo ""
            echo -e "${GREEN}=========================================="
            echo "  ✓ Deployment completed successfully"
            echo "==========================================${NC}"
            echo ""
            echo "Version deployed: ${TAG}"
            echo "Image: ${IMAGE_NAME}:${TAG}"
            echo "Health check: ${HEALTH_CHECK_URL}"


